	title	BOOTSYS	- CPM3.SYS 1.20
	subttl	Copyright (C) 2000,2014 Andreas Gerlich
	page	70,132
;------------------------------------------------------------------------------
; BOOTSYS relocates and places the resident and banked (if present) parts
; of a CPM3.SYS to their right places into memory and starts CP/M 3.1.
; You generate a cpm3.com for starting CP/M 3.1 with:
;	pip cpm3.com=bootsys.com,cpm3.sys
;
; Copyright (C) Andreas Gerlich (Andreas.Gerlich@mathematik.uni-ulm.de)
;
; BOOTSYS is free software; you can redistribute it and/or modify it under
; the terms of the GNU General Public License as published by the Free
; Software Foundation; either version 2 of the License, or (at your
; option) any later version.
;
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
;
; BOOTSYS WILL NOT WORK ON ALL CP/M 3.1 SYSTEMS. Why?
; If the MOVE, XMOVE are placed in the banked part of the BIOS then it is
; possible for those routines to be overwritten when bootsys+cpm3.sys are
; transferred to bank 0.
;
; Try it.  If this utility works under your CP/M 3 system then you can start
; a new version of your system from the current one without having to write
; it to the system tracks.
;
; Bootsys works always under CP/M 2.2 to relocate and start a nonbanked or
; a banked CP/M 3.1.
;
; You generate a cpm3.com for starting CP/M 3.1 with:
;	pip cpm3.com=bootsys.com,cpm3.sys
;-----------------------------------------------------------------------------
; 2014-01-14 Jon Saxton
; .  Added many comments in English. Shortened and/or corrected some messages.
; .  Fixed bug in XMOVE/MOVE sequence of calls.
; .  Adjusted calculation of CPM3.SYS location.
; .  Updated version number and copyright notice.
;
; Some explanation of the XMOVE/MOVE change is warranted.
;
; The original code moved (or tried to move) a large block of code from
; bank 1 to bank 0 and then executed that code in bank 0.  It did this
; with three BIOS calls:
;	XMOVE		to set the source and destination banks
;	MOVE		to actually copy the code
;	SELMEM		to switch to bank 0
; The addresses of those three BIOS routines are calculated but the Z80 has
; no instruction to call a computed address so the program stacked the three
; return addresses and at the appropriate locations simply executed a JP (HL)
; instruction.
;
; That approach works in YAZE-AG because the memory management is done in the
; emulator code rather than in CP/M.  On real hardware it is generally doomed
; because of the way that inter-bank transfers are implemented.
;
; The description of the XMOVE routine in the CP/M 3 System Guide states:
;	"After a call to XMOVE function, the following call to the MOVE
;	 function is not more than 128 bytes of data."
; Without special hardware (namely a DMA controller capable of doing inter-
; bank memory transfers) XMOVE must be inplemented using a small buffer in
; common memory, typically one generated by GENCPM for the purpose.  The
; large transfer done by BOOTSYS overruns that buffer and effectively
; destroys everything in memory.
;
; While it is certainly possible to implement a large-transfer inter-bank
; MOVE in the BIOS that is generally not done because of the aforementioned
; assurance that at most 128 bytes would be copied between memory banks.
; It was necessary to modify BOOTSYS so that it would call XMOVE and MOVE as
; often as necessary, copying 128 bytes at a time.
;
; Clearly the return-address-stacking method of perfoming computed calls
; is impractical when an indeterminate number of calls needs to be made to
; XMOVE and MOVE.  Fortunately there is a simple workaround; it is as easy
; as this:
;
;	compute	hl,<address>	; Subroutine address to HL
;	call	@HL		; Call surrogate routine
;	...
;
; @HL:
;	jp	(hl)		; Execute function 
;
; Obviously the first line is not a real instruction; it just represents some
; sequence of operations which leave the target subroutine address in HL.
;
; In practice I put some more stuff in the surrogate routine to save code
; duplication so the code in this source file is a bit more elaborate.
;-----------------------------------------------------------------------------
	if0
	.printx	'BOOTSYS - CPM3.SYS 1.23'
	endif

	.z80	; Code uses Z80 instructions

cr	equ	13
lf	equ	10
ht	equ	 9
quote	equ	22h

	aseg
	org	100h

;---------------------------------------------------------------------------
; 8086 Prefix by Andreas Gerlich. Necessary if bootsys.com/cpm3.com is
; running on a MS-DOS/Windows system. On a MS-DOS/Windows system this
; prefix prints a message and exits.
;

	db	0EBh	  ; -*----  ex de,hl   (Z80)
			  ;   \
			  ;    +--  jmp 011Ah  (8086)
			  ;   /
	db	018h	  ; ==
			  ;   \
	db	begin-$-1 ; ---+--  jr begin   (Z80)
	; please ensure the relative jump destination is less then 80h away.

	; Von Adresse 103 bis 11a ist Raum frei. Die Anzahl der nachfolgenden
	; Bytes sollte nicht erhoeht werden!
	;	|                       |
	;
	db	'8086 prefix by agl ;-) ' ; room for a little Message ;-)
	;
	;
;	org	 011ah	 ; must begin at this address

	db	0bah		; move dx,DOS_Txt (8086)
	dw	DOS_Txt
	db	0b4h,09h	; mov ah,09h	(8086, print string)
	db	0cdh,021h	; int 21	(8086, MSDOS)
	db	0b4h,01h	; mov ah,01h	(8086, input one character)
	db	0cdh,021h	; int 21	(8086, MSDOS)
	db	0cdh,020h	; int 20	(8086, End Programm)

begin:	jp	main

DOS_Txt:db	13,10,'Z80 or CP/M emulator required!',13,10,10

	db	'BOOTSYS is a new loader for a CPM3.SYS to load and run'
	db	cr,lf
	db	'CP/M 3.1 in a Z80 emulator or on a real CP/M-Z80 system.'
	db	cr,lf,lf
	db	quote, 'Yet Another Z80 Emulator by AG', quote, ' is a Z80 '
	db	'Emulator.',cr,lf
	db	'It is designed to provide an exact simulation of the',cr,lf
	db	'Z80 microprocessor on a UNIX/Linux system.',cr,lf,lf
	db	'You can find yaze-ag under',cr,lf,lf
	db	ht,'http://www.mathematik.uni-ulm.de/users/ag/yaze-ag/',13,10
	db	'     or',cr,lf
	db	ht,'ftp://ag-yaze:yaze@xylopia-upload.mathematik.uni-ulm.de'
	db	cr,lf,lf
	db	'Press any key to continue ...'
	db	'$'


;---------------------------------------------------------------------------
; TODO:
;
; 0. ERLEDIGT und getestet
;    Wenn CP/M 3 laeuft!
;    Bootsys+cpm3.sys mit Interbankmove alles nach Bank 0 transferieren
;    (source und dest beides 0100H) dort ausfuehren (durch wechsel nach
;    bank 0).  (BIOS Funktion xmove ueberpruefen ob vorhanden)
;	Die funktion conout und conin sollten alle direkt ueber das
;	Bios gehen und die Adresse von wboot sollte am Anfang abgesichert
;	werden und nur diese fuer alle spaeteren Operationen benutzt werden.
;	Warum? Nach dem Wechsel von bank 1 nach 0 werden noch Ausgaben
;	und Eingaben getaetigt (diese duerfen (nach page 67/68 System Guide)
;	direkt im bios aufgerufen werden), die CP/M Vektoren sind aber nicht
;	mehr vorhanden.
;
; 0. Done and tested:
;    When CP/M 3 is running
;    Transfer bootsys+cpm3.sys from bank 0 to bank 1 with interbank move
;    (source and destination both 100h) and execute from 0:100h.  Ensure
;    BIOS function XMOVE exists.
;
;    The functions CONOUT and CONIN should be in common memory and the warm
;    boot address should be at the start.  This will be used for subsequent
;    operations.  Why?  After the transfer from bank 1 to bank 0 the program
;    still needs to make console I/O calls and according to page 66/67 of
;    the system guide these functions may be called directly via the jump
;    vector.
;
; 1. ERLEDIGT und getestet
;    Nachsehen ob die Vektoren bei 0 und 5 da sind (C3H nachsehen und ob
;    die zwei Adressen plausibel sind (wboot > bdos)).
;	Nein --> Auf jedenfall Booten und fuer die Ein-/Ausgaben direkt YAZE
;		 benutzen (Ein anderes System wird bei Halt entsprechen
;						nicht mehr reagieren ;-))
;	Ja   --> Fuer die Ausgaben CP/M benutzen (conout/-in ueber bios).
;		 Parameter nachpruefen (wenn gegeben nur Copyright ausgeben).
;
; 1. DONE and tested
;    See if the vectors at 0 and 5 exist (check for JP and see whether
;    the two addresses are plausible (?wboot > BDOS).
;       No ->	boot anyway and if running YAZE then it should work.
;		(Another system will no longer respond ;-))
;       Yes ->	For spending CP/M use (conout/conin about bios).
;		Parameter re-examine (if given only spend copyright).
;
; 2. ERLEDIGT und getestet bzw. siehe 0.
;    CP/M Version ueberpruefen (nur wenn Vektoren da sind).
;	Wenn Version 3 dann Meldung ausgeben (Bitte unter 2.2 ausfuehren).
;
;	ODER siehe 0 (Diese Funktion sollte nach der ueberpruefung der
;	Copyright Message erfolgen.)
;
; 2. Done and tested (or see #0)
;    CP/M version checking (only when vectors are present).  If version 3
;    then output message.  (For CP/M 2.2 please specify.)
;
; 3. ERLEDIGT und getestet
;    Ueberpruefen ob eine CPM3.SYS angehaengt ist. (ueber Copyright Message)
;
; 3. Done and tested
;    Check that CPM3.SYS is appended. (Look for Copyright message.)
;
; 4. VERWORFEN
;    Zwischenpuffer auf printrecord (wieder verworfen und absolute auf 0080H
;    gesetzt. Diese File wird immer auf 0100H geladen)
;
; 4. Rejected
;    Use intermediate file buffer in print record. (Again, always use absolute
;    address 80h.  This file is always loaded at 100h.)
;
; 5. ERLEDIGT und getestet
;    Nonbanked Sytem booten
;---------------------------------------------------------------------------
;
Copyright_message::
	db	cr,lf
	db	'BOOTSYS - CPM3.SYS, v'

	db	'1.23 13.01.2014'	;<--- VERSION

	db	' Copyright (c) 2000,2014 by'
	db	' A. Gerlich',cr,lf
Dollar::db	'$'

; Message die ausgegeben wird wenn bootsys ohne vorhandenem CP/M booten will
; (hierzu wird das Dollar 3 Zeilen weiter oben ersetzt)
;
; Message displayed when CP/M is not found.
	db	 'No CP/M vectors found; try to boot CP/M 3.1'
	db	' using yaze-ag ...',cr,lf,'$'
;
;---------------------------------------------------------------------------

wboot		equ	0
wbootvek	equ	wboot+1
bdos		equ	5
bdosvek		equ	bdos+1
parameter	equ	wboot+80h

;----------------------------------------------------------------------------
; Call a BIOS function.
;
; Load the relevant registers and use the BIOS macro to invoke the function.
;----------------------------------------------------------------------------

bios	macro	func
	ex	af,af'		; Save A register
	ld	a,func*3-3	; Offset into BIOS vector
	call	goBIOS		; Invoke BIOS function
	endm

goBIOS::
	push	de		; Save DE while we compute
	ld	iy,(wbootvek)	; Get BIOS warm boot address
	ld	e,a		; Form 16-bit addend
	ld	d,0
	add	iy,de		; Function address now in IY
	pop	de		; Restore DE
	ex	af,af'		; Restore A
	jp	(iy)

SELMEM	equ	27
MOVE	equ	25
XMOVE	equ	29

;----------------------------------------------------------------------------

	; MAIN

main::	ld	sp,lstack	; Stack setzten

	; CP/M Vektoren ueberpruefen
	; Check CP/M vectors
	ld	a,0C3h		; OP-Code fuer JP
	ld	ix,0
	cp	a,(ix+wboot)	; Ist an der Stelle von WBOOT ein JP-Opcode
	jp	nz,nocpmvektoren; nein --> direkt CPM booten mit YAZE

	cp	a,(ix+bdos)	; Ist an der Stelle von BDOS ein JP-Opcode
	jp	nz,nocpmvektoren; nein --> direkt CPM booten mit YAZE

	; JP-opcodes vorhanden
	; ueberpruefen ob BDOS-Adresse kleiner als die WBOOT-Adresse ist
	; JP opcodes have been verified.  Now ensure that the BDOS is lower
	; than the BIOS.
	ld	hl,(wbootvek)
	ld	de,(bdosvek)
	or	a		; Ensure CF is off
	sbc	hl,de		; HL = wboot - bdos
	jp	c,nocpmvektoren	; Carry flag: bdos-addresse ist groesser als
				;	      die warmboot-adresse
				;     (bdos muss immer kleiner als wboot sein)
	jp	z,nocpmvektoren	; Zero Flag: beide Adressen sind gleich
				; (Duerfte praktisch nie vorkommen, aber
				;  man weis ja nie (Murphy laesst gruessen :-))

	; CP/M Vektoren sind vorhanden

	ld	(cpmvek),a	; Boolsche Variable "CP/M Vektoren" setzen.
				; (Ab jetzt werden Ein-/Ausgaben ueber das
				; BIOS getaetigt.)

	ld	sp,(bdosvek)	; Stack auf top von TPA setzen
				; Stack at top of TPA.
	ld	hl,(wbootvek)	; Warmbootvektor absichern (wird ab jetzt
	ld	(wbvektor),hl	;	   bei Character in/out verwendet !)

	; CP/M Vektoren sind vorhanden
	; --> ueberpruefen ob ein Parameter gegeben wurde

	ld	hl,Copyright_message	; Copyright message ausgeben
	call	PRSTRfunc		; Display copyright message

	ld	a,(parameter)
	or	a		; Ist irgend ein Parameter vorhanden?

;	jr	z,testcopyright	; nein --> go on
;
;	jp	wboot		; und beenden

	jp	nz,wboot	; ja --> beenden

	; Copyright Message von Digital Research in CPM3.SYS ueberpruefen

testcopyright::

	; Testet ob eine Copyright message vorliegt. Im anderen Fall
	; ist sehr wahrscheinlich noch kein CPM3.SYS angehaengt worden.
	;
	; Test for copyright message.  If none is present then it is likely
	; no CPM3.SYS was appended.

	; CPM3.COM wird mit PIP cpm3.com=bootsys.com,cpm3.sys erzeugt.

	ld	hl,CPM3SYS+copyrmsg
	ld	de,CopyDRI
	ld	bc,CDRIlen - CopyDRI

cloop::	ld	a,(de)
	cpi			; vergleich A mit (HL) (A-[HL], HL++, BC--)
	jr	nz,nocopyright	; ungleich (nicht null) --> nocopyright
	jp	po,testecpmversion; p=odd (gesetzt)? --> BC=0 --> Alle
				; character sind identisch --> go on
	inc	de
	jr	cloop

nocopyright::
	ld	hl,m_nocopyright
	call	PRSTRfunc

exit::
	ld	a,(cpmvek)
	or	a,a		; sind CP/M Vektoren vorhanden?
				; Were CP/M vectors found?
	jp	nz,wboot	; ja --> Warm boot

	halt
	db 0ffH			; exit yaze

nocpmvektoren::
	; Sind keine CP/M Vektoeren vorhanden wird davon ausgegangen
	; Yaze-ag laeuft.

	ld	a,95h		; I/O-Byte setzen fuer yaze. Ist notwendig wenn
	ld	(3),a		; bootsys+cpm3.sys beim Start von yaze-ag von
				; der Unix-file yaze-cpm3.boot gebootet wird.

				; I/O byte set for Yaze.  Necessary if yaze-ag
				; is booted from UNIX file yaze-cpm3.boot

	ld	hl,Dollar	; Dollarzeichen ersetzen
	ld	(hl),' '	; new line
	ld	hl,Copyright_message
	call	PRSTRfunc
	jp	testcopyright

testecpmversion::
	ld	a,(cpmvek)	; Sind CP/M Vektoren vorhanden?
	or	a,a
	jr	z,loadcpm3	; Nein --> gleich CP/M 3 laden

	; CP/M Version testen

	ld	c,12		; Versionsnummer von CP/M holen
	call	bdos

	ld	a,l
	and	a,030h		; nur oberer Teil beruecksichtigen
	cp	a,030h
	jr	nz,loadcpm3	; ungleich Version 3x --> CPM3.SYS sofort laden

	; wenn CP/M 3.1 bereits laeuft
	; XMOVE ueberpruefen

	ld	de,(29-1)*3	; -1 wegen Warmboot, 29 ist Position von XMOVE
	ld	hl,(wbootvek)	; hole Adresse von Warmboot
	add	hl,de		; hl points to the xmove-jmp in bios-table
	inc	hl		; points to jmp address
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a		; hl points to the xmove routine itself

	; now test if RET instruction is available for xmove-routine

	ld	a,0C9h		; RET-Opcode
	cp	(hl)
	jp	nz,MoveToBank0	; No RET --> xmove vorhanden --> ales nach bnk0
				; No RET --> xmove available --> all to bank 0
	ld	hl,no_xmove_message
	call	PRSTRfunc
	jp	exit

	; XMOVE seems to be implemented
	; --> try to move all to bank 0

MoveToBank0:
	ld	hl,bank1_message
	call	PRSTRfunc

	.comment #

 ---------------   DELETED CODE   ---------------
|    |    |    |		  |    |    |    |
v    v    v    v		  v    v    v    v

	; Die folgenden Returnadressen muessen vor dem interbank Move auf
	; den (lokalen) Stack liegen, damit sie auch in bank 0 existieren !!!

	ld	hl,RET3
	push	hl		; Return adress RET3 on stack
	ld	hl,RET2
	push	hl		; Return adress RET2 on stack
	ld	hl,RET1
	push	hl		; Return addres RET1 on stack

	; I don't use BDOS function 50. I tested it and it does not work.
	; I think that the banked part of the BDOS is used when function 50
	; is called but when bootsys.com+cpm3.sys is moved from bank 1 to
	; bank 0 the banked part will be overwritten.  Thus I use the BIOS
	; functions XMOVE, MOVE and SELMEM directly to transfer bootsys+
	; cpm3.sys to bank 0 and to switch to bank 0!
	;
	; In the yaze BIOS the interbank transfer is realised in C outside the
	; Z80 memory and the short routines (HALT, func in yaze BIOS and ret)
	; are in the resident part of the BIOS, so it all works in yaze.

	ld	de,(29-1)*3	; -1 wegen Warmboot, 29 ist Position von XMOVE
	ld	hl,(1)		; hole Adresse von Warmboot
	add	hl,de		; hl points to the xmove-routine in BIOS

	ld	bc,0001h	; B=bank 0 (dest),  C=bank 1 (source)
	jp	(hl)		; call XMOVE, return address (RET1) is on stack

RET1::	ld	de,(25-1)*3	; 25 is the position of MOVE
	ld	hl,(1)
	add	hl,de		; hl points to the move routine in BIOS
	push	hl		; --> to stack (will be called with ret)

	ld	ix,CPM3SYS	; dort beginnt CPM3.SYS
	ld	a,(ix+reslen)
	add	a,(ix+bnklen)	; Gesamtlaenge <reslen> + <bnklen> berechnen
				; Calculate total length (resident + banked)
	ld	bc,CPM3SYS	; dort beginnt CPM3.SYS
	add	a,b		; += Offset vom CPM3.SYS Binary
	ld	b,a		; BC = <reslen> + <bnklen> + Offset CPM3.SYS

	ld	hl,0100h	; destination (bank 0) fuer move
	ld	de,0100h	; source (bank 1)
	ret			; call MOVE in bios (address on stack)

RET2::	; All is transfered to bank 0; now switch to bank 0.  That must be
	; done directly because BDOS function 50 does not allow a call to
	; BIOS function 27. See page 3-72 BDOS function "direct BIOS calls"

	; ld	hl,RET3 	; siehe oben
	; push	hl

	ld	de,(27-1)*3	; offset fuer SELMEM
	ld	hl,(1)
	add	hl,de		; hl points to SELMEM

	xor	a		; a <- 0 (bank 0)
	jp	(hl)		; call SELMEM
RET3::
^    ^    ^    ^		  ^    ^    ^    ^
|    |    |    |		  |    |    |    |
 ---------------   DELETED CODE   ---------------

 ---------------     NEW CODE     ---------------
|    |    |    |		  |    |    |    |
v    v    v    v		  v    v    v    v
	#

	; The next six lines were copied from the original code ...
	ld	ix,CPM3SYS	; dort beginnt CPM3.SYS
	ld	a,(ix+reslen)
	add	a,(ix+bnklen)	; Gesamtlaenge <reslen> + <bnklen> berechnen
				; Calculate total length (resident + banked)
	ld	bc,CPM3SYS	; dort beginnt CPM3.SYS
	add	a,b		; += Offset vom CPM3.SYS Binary
	ld	b,a		; BC = <reslen> + <bnklen> + Offset CPM3.SYS

	; We need to move this entire program plus the attached CPM3.SYS
	; from the current bank (1) to the system bank (0).  We do it in
	; a series of 128-byte interbank moves.
	;
	; BC contains the total number of bytes which need to be copied.
	; It is known to be an exact multiple of 128 bytes so a test for
	; BC=0 is sufficient to detect the end of the transfer.

	ld	hl,100h		; Destination address in bank 0
	ld	d,h		; Same source address in bank 1
	ld	e,l
copy128:
	ld	a,b		; See if move is finished. This test is valid 
	or	c		; because BC was originally a multiple of 128
	jr	z,bank0
	push	bc		; Save byte count
	ld	bc,0001h	; B=destination bank (0), C=source bank (1)
	bios	XMOVE		; Set up for inter-bank move
	ld	bc,128		; Number of bytes to move
	push	bc		; Save for subtract
	bios	MOVE
	; According to the CP/M 3 System Guide DE and HL should now point at
	; the bytes immediately beyond those that were copied.  This means
	; that the pointers are ready for the next call to MOVE.
	exx			; Save source and destination
	pop	de		; Subtrahend
	pop	hl		; Byte count
	or	a		; Clear carry flag
	sbc	hl,de		; Decrement bytes to move
	push	hl		; Stack it
	exx			; Recover source and destination pointers
	pop	bc		; Recover remaining bytes
	jr	copy128
bank0:
	xor	a		; Set bank 0
	bios	SELMEM
	.comment #
^    ^    ^    ^		  ^    ^    ^    ^
|    |    |    |		  |    |    |    |
 ---------------     NEW CODE     ---------------
	#
	nop	; now this instruction will be executed in bank 0

	ld	hl,bank0_message
	call	PRSTRfunc

;---------------------------------------------------------------------------
; Hier beginnt der eigentliche Lader fuer CPM3.SYS.
; This is the start of the actual CPM3.SYS loader.
;---------------------------------------------------------------------------
;
; The following information is from page 115 Appendix D of the System Guide
;
;
; CPM3.SYS File Format:
;
;	0	Header Record (128 bytes)
;	1	Print Record (128 bytes)
;	2-n	CP/M 3 operating System in reverse order, top down.
;
;
; Header Record Definitions:
;
; CPM3.SYS (see at the end) ; Start of CPM3.SYS

restop	equ	0	; Top page plus one, at which the resident partion
			; of CP/M 3 is to be loaded top down.

reslen	equ	1	; Length in pages (256 bytes) of the resident
			; portion of CP/M 3.

bnktop	equ	2	; Top page plus one, at which the banked portion
			; of CP/M 3 is to be loaded top down.

bnklen	equ	3	; Length in pages (256 bytes) of the banked
			; portion of CP/M 3.

coldboot equ	4	; Address of CP/M 3 Cold Boot entry point

copyrmsg equ	16	; Copyright Message



; Print Record:
;
; The Print Record in the CP/M 3 Load Table is ASCII,
; terminated by a dollar sign ($).

prrecord equ	128	; position of the Print Record

;---------------------------------------------------------------------------

zwsp	equ	80h
zwsptop	equ	zwsp+127; letztes Byte in Zwischenspeicher
			; Last byte in buffer

; Kleiner Hinweis:	Wenn ich von "oberen Bereich" spreche, so ist damit
;			der Teil gemeint der adressmaessig weiter oben liegt
;			Dasselbe analog bei der Bezeichnung "unterer Teil".
;
; Note:			When I say "upper range" I am referring to the 
;			addresses above.  Analogous reasoning applies for
;			"lower portion".

loadcpm3::
	ld	hl,loadmsg	; Text "Loading ..." ausgeben
	call	PRSTRfunc	; Emit "Loading ..."

	ld	hl,CPM3SYS+prrecord	; Printrekord ausgeben
	call	PRSTRfunc		; Emit print record

	ld	sp,lstack	; Nach allen Ausgaben Stack wieder
				; auf local stack setzten

	; Zuerst den residenten Teil kopieren.
	; Im SPR-Format sind alle Sektoren Seiten-Buendig in 128 Byte
	; Bloecken (log Sektor) abgelegt. Die Ablage erfolgte jedoch
	; upside-down, d.H. der letzte Sektor wird zuerst gelesen.
	;
	; First copy the resident portion.  In the .SPR format 128-byte
	; records are stored adjacent but upside-down; i.e. the last
	; sector is read first.

	ld	ix,CPM3SYS	; dort beginnt CPM3.SYS
	ld	d,(ix+restop)
	ld	e,0		; DE <- top of resident part (<restop>)
	ld	a,(ix+reslen)	; LEN of resident part (in 256-byte pages)
	add	a,a		; *2 = Anzahl der log Sektoren (128 Byte)
				; Muss mal 2 genommen werden da in <reslen>
				; die Anzahl von 256 Byte Pages abgelegt ist.
				; Double the number of pages to convert to
				; 128-byte blocks.
	ld	hl,CPM3SYS+100h ; Zeiger auf 2. Record (1. Binary of CP/M 3)

	call	transfer	; A=Bloecke von HL-->DE (upside down)


	; HL zeigt nun auf den Begin des banked Teils und somit
	; auf den erster log. Sektor des unteren Bereichs
	;
	; HL now points to the start of the banked portion and thus to
	; the first logical sector of the lower part.

	push	hl		; Fuer Berechnung auf Stack

	exx			; 2 Registersatz fuer oberen Bereich

	pop	hl		; HL <- zeiger auf banked part

	ld	a,(ix+bnklen)	; LEN of banked part (<bnklen>)
	or	a,a		; Ist die Laenge fuer banked part 0
	jr	z,bootcpm3	; ja --> nonbanked System sofort booten

	; Wenn nein, banked part laden
	; Non-zero banked length; load the banked part

	add	a,h		; oberste page berechnen
				; Calculate the top page
	ld	h,a		; HL zeigt genau hinter den obersten
				; Sektor (banked part)
				; HL points just beyond the top sector
				; of the banked part
	dec	hl		; hl zeigt auf das letzte Byte des
				; des obersten log. Sektors

	ld	a,(ix+bnklen)	; LEN of banked part (<bnklen> 256 Byte pages)
				; (zum zaehlen)

	; Dieser Zaehler darf NICHT *2 genommen werden so wie oben.
	; Folgende Grafik verdeutlicht den Vorgang:
	;
	;
	;				+----------+<----<<--+
	;				| zwsp	   |-->>+    |
	;				+----------+	|    |
	;					     (3)|    |
	;						|    |
	;						|    |
	; Begin banked Bereich -------> +----------+<-<<+    |
	;  (unterer Bereich)	  ^	| page 0   |->>-+    |
	;			 256	+----------+	|    |(1)
	;			  |	| page 1   |	|    |
	;			-----	+----------+	|    |
	;				    ... 	|    |
	;				    ...      (2)|    |
	;				    ... 	|    |
	;				    ... 	|    |
	;				+----------+	|    |
	;				| page n-1 |	|    |
	;				+----------+<-<<+    |
	;  (oberer Bereich)		| page n   |----->>--+
	; End banked Bereich ---------> +----------+
	;
	;
	; Ein Austauschzyklus besteht aus den Schritten:
	;
	; (1) 128 Bytes vom oberen Bereich in den Zwischenspeicher
	; (2) 128 Bytes vom unteren Bereich in den oberen Bereich
	; (3) 128 Bytes vom Zwischenspeicher in den unteren Bereich
	; (4) Pointer unterer Bereich um +128 erhoehen
	;     Pointer oberer Bereich um -128 erniedrigen
	;     (Der Vorgang des Pointerverschiebens erfolgt automatisch
	;      ueber die Pointer der Befehle lddr und ldir.)
	;
	; Es werden also n/2 Vertauschungen gemacht und die Pointer treffen
	; sich genau in der Mitte (oberer Bereich wird mit dem unteren
	; Bereich spiegelverkehrt ausgetauscht). Wobei gilt <bnklen> = n/2.
	; Der Wert aus <bnklen> darf fuer den Austauschvorgang also
	; unveraendert benutzt werden, da hier genau die obere Haelfte mit
	; der unteren Haelfte spiegelverkehrt ausgetauscht wird.
	;------------------
	; The numerator should NOT be taken as *2 above.
	; The following diagram illustrates the process:
	;
	;
	;				+----------+<----<<--+
	;				| zwsp	   |-->>+    |
	;				+----------+	|    |
	;					     (3)|    |
	;						|    |
	;						|    |
	; Begin banked Bereich -------> +----------+<-<<+    |
	;  (unterer Bereich)	  ^	| page 0   |->>-+    |
	;			 256	+----------+	|    |(1)
	;			  |	| page 1   |	|    |
	;			-----	+----------+	|    |
	;				    ... 	|    |
	;				    ...      (2)|    |
	;				    ... 	|    |
	;				    ... 	|    |
	;				+----------+	|    |
	;				| page n-1 |	|    |
	;				+----------+<-<<+    |
	;  (oberer Bereich)		| page n   |----->>--+
	; End banked Bereich ---------> +----------+
	;
	;
	; The loop comprises the following steps:
	;
	; (1) 128 bytes from the upper region into the intermediate area
	; (2) 128 Bytes from the lower region to the upper region
	; (3) 128 Bytes from intermediate storage to the lower portion
	; (4) Increment the lower address pointer by 128
	;     Decrement the upper address pointer by 128
	;     (The pointer adjustments done automatically by LDDR and LDIR.)
	;
	; n/2 exchanges are made and the the pointers are left in the middle
	; of the range.  The effect is a mirror reordering of the code.  Bear
	; in mind that the number of logical sectors swapped is <bnklen> so
	; that value can be used unchanged.
	;
	;--------------

loop::
	; HL zeigt auf das letzte Byte des oberen Teils (updown)
	; oberen Teil in den scratch Bereich
	; HL is the last byte of the upper part of the scratch area.

	ld	de,zwsptop	; letztes Byte des Zwischenspeichers
				; Last byte of the buffer
	ld	bc,128		; 128 Bytes
	lddr			; transferiere nach zwsp 128 Bytes rueckwaerts
				; Transfer 128 bytes backwards

	; hl zeigt auf letztes Byte des vorherigen Sektors
	; HL points to the last byte of the previous sector

	push	hl		; fuer den naechsten move als zieladresse
				; absichern
				; Save HL as destination address for the
				; next move 
	exx

	; HL zeigt auf die source vom unteren Teil (lowup)
	; unteren Bereich in den oberen Bereich verschieben
	; HL is the source from the lower region.
	; Move from lower to upper.
	push	hl		; wird gleich nochmal benoetigt
	pop	iy		; ins IY

	pop	de
	inc	de		; de zeigt auf ziel
				; DE points at target

	ld	bc,128		; 128 Bytes
	ldir			; vorwaerts transferieren

	; vom scratchbereich transferieren
	; Transfer from intermediate buffer

	push	iy		; hole pointer auf unteren Bereich (lowup)
	pop	de		; als destination

	ld	hl,zwsp		; scratch Bereich
	ld	bc,128		; 128 Bytes
	ldir

	; DE steht auf naechstem Sektor vom unteren Teil (lowup)

	ex	de,hl		; HL steht auf dem naechsten Sektor.
				; Wird fuer den naechsten move in HL
				; erwartet
	exx

	; Nun sind beide Sektoren vertauscht. (Sectors are swapped.)
	; HL und HL' stehen jeweils auf den naechsten log Sektor:
	;(HL and HL' are ready for the next logical sector swap:)
	; HL' (um 128 Bytes hoeher [higher])
	; HL  (um 128 Bytes niedriger [lower])

	dec	a		; --a, ist letzter Sektor vertauscht?
	jr	nz,loop		; nein --> loop

; Damit liegt der code in der richtigen Reihenfolge vor. Jetzt muss er
; nur noch an die richtige Stelle transferiert werden und ins Bios
; eingesprungen werden.
;
; The code is in the correct order.  Now it must be transferred to the
; correct place and control given to the BIOS.

	ld	hl,CPM3SYS+0100h ; Beginn vom CPM3 binary

	ld	a,(ix+reslen)
	add	a,(ix+bnklen)	; Gesammtlaenge <reslen> + <bnklen> berechnen

	add	a,h		; += Offset vom CPM3 Binary
	ld	h,a
	dec	hl		; HL steht auf dem letzten Byte des
				; banked Parts
				; HL -> last byte of the banked part
	ld	d,(ix+bnktop)
	ld	e,0
	dec	de		; DE zeigt auf (<bnktop>*256)-1, also ein
				; Byte vor COMMON Memory
				; DE points at (<bnktop>*256)-1, i.e. one
				; byte below common memory

	ld	b,(ix+bnklen)
	ld	c,0		; BC beinhaltet die Laenge vom banked Bereich
				; BC holds the length of the banked portion

	lddr			; und transferieren von oben her


; Damit sollte der Code in der richtigen Reihenfolge an der richtigen
; Position stehen.
; Jetzt CP/M 3 booten (BIOS einspringen):

bootcpm3::
	ld	l,(ix+coldboot)
	ld	h,(ix+coldboot+1)

	jp	(hl)		; und CP/M 3.1 starten

;--------------------------------------------------------------------------
; subroutines
;
; transfere: transferiert upside down den residenten Bereich

transfer::
	; Uebertragen von <A> log. Sektoren (128 Byte Bloecken) von
	; HL-->DE. (upside down)
	; Copy <A> logical sectors from <HL> to <DE>
	ex	de,hl		; Ziel nach HL
	ld	bc,-80h
	add	hl,bc		;
	ex	de,hl		; erster Block
trans1::ld	bc,80h		;  Laenge
	ldir			; uebertragen von HL-->DE
	dec	d		;  Ziel - 100h
	dec	a		; Zaehler
	jr	nz,trans1
	ret

.comment #
------------------------ Not used -------------------------
callbios::
	ld	(func),a	; bios function number

	ex	af,af'
	ld	(Areg),a
	ld	(BCref),bc
	ld	(DEreg),de
	ld	(HLreg),hl

	ld	de,biospb
	ld	c,50		; Bios func
	call	bdos		; return Address on Stack
	ret

biospb::
func::	db	0
Areg::	db	0
BCref::	dw	0
DEreg::	dw	0
HLreg::	dw	0
----------------------------------------------------------
#

PRSTRfunc::
	ld	a,(hl)
	cp	a,'$'
	ret	z		; if ch='$' --> return
	push	hl		; HL wird von conout veraendert
	ld	c,a
	call	conout		; call conout in CP/M-bios or yaze-bios direkt
	pop	hl
	inc	hl		; pointer to the next char
	jr	PRSTRfunc

conout::
	ld	a,(cpmvek)
	or	a,a		; existieren CP/M Vektoren
	jr	z,yaze_conout	; NEIN --> direkt Yaze-conout benutzen

	; conout im BIOS aufrufen

	ld	hl,(wbvektor)
	ld	de,3*3		; ab wboot der 3. Vektor
	add	hl,de
	jp	(hl)		; Returnadresse ist auf dem Stack

yaze_conout::
	halt
	db 04			; call conout im yaze-bios
	ret

;--------------------------------------------------------------------------

	; Die folgende Zeile darf nicht veraendert werden, denn
	; dieser wird zum Ueberpruefen der Copyright Message in CPM3.SYS
	; verwendet
CopyDRI::db	'Copyright (C) 1982, Digital Research'
CDRIlen	equ	$

no_xmove_message::
	db	cr,lf
	db	'CP/M 3.1 is running but your BIOS does not implement XMOVE.'
	db	cr,lf,lf
	db	'To load and start CP/M 3.1 from this file'
	db	' you must be running CP/M 2.2.',0dh,0ah,0ah
	db	'$'

loadmsg::db	cr,lf,'Loading CP/M 3.1 ...',cr,lf,'$'

bank1_message::
	db	cr,lf
	db	'CP/M 3.1 is already running and bank 1 is selected!'
	db	cr,lf
	db	'Now move everything to bank 0 ...',cr,lf
	db	'$'

bank0_message::
	db	cr,lf
	db	'Everything is copied and bank 0 is selected; '
	db	'CPM3.SYS will be loaded. :-)'
	db	cr,lf
	db	'(This message is printed after a switch to bank 0)'
	db	cr,lf
	db	'$'

m_nocopyright::
	db	cr,lf
	db	'No signature found.  It seems there is no CPM3.SYS attached.'
	db	cr,lf
	db	'Use "pip cpm3.com=bootsys.com,cpm3.sys" to attach a'
	db	' CPM3.SYS.',cr,lf,lf
	db	'$'

cpmvek::	db	0	; Muss 0 sein, wird so erwartet !!!
wbvektor::	dw	0	; Adresse des Warmboots

	ds	16,0AAH		; initialized is better
lstack::			; for the next instruction


;CPM3SYS equ	$ and 0FF80h + 80h
	; damit faengt CPM3.SYS auf einer 80H Pagegrenze an
	; So CPM3.SYS starts on a 128-byte boundary.
	;
	; Something to consider ...
	;
	; What if this program ends exactly on a 128-byte boundary?  For
	; example, suppose lstack is 2000h.  CPM3SYS should start at 2000h
	; but the calculation would yield 2080h.
	;
	; I think this is a better calculation:
CPM3SYS equ	($+7Fh) and 0FF80h

	end

